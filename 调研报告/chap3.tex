\chapter{Unikernel的优势和劣势}

\section{优势}

Unikernel采用的设计专门操作系统的想法并不是第一个，eliminate general purpose operating system的想法早就有人提出来了，但是
应用的场景实在太小，无法得到大范围应用。但是现在Unikernel的适用环境恰恰符合云计算平台--我们需要让虚拟机更小，更快，更安全。

小： 很多虚拟机镜像因为移除了复杂的软件栈，常常不足1MB，完成的功能相同，这并不奇怪--比如我要写一个hello world程序，不需要shell，
不需要网卡驱动，只需要一些I/O的管理和进程调度即可。当前的软件堆栈（software stack）一般由成百上千个部分组成，经常需要使用千兆字节
的内存和磁盘空间。他们花费大量宝贵的时间用于启动和关闭，大而缓慢。自从IBM PC出现之后，人们构建软件堆栈的方法几乎没有变化。37年来，
我们一直在采用在硬件大而缓慢的时候设计的堆栈方法。如今，硬件系统已经发生了天翻地覆的变化，操作性能比过去有了数千倍的提高，为什么我们
还在使用这种已经显然过时的堆栈方法呢？如果硬件系统发生了如此大的变化，那么软件系统是否也需要相应的进化以适应硬件的发展呢？

答案是显然的。Unikernal的出现正是对这一需求的呼应。想象一下一下子抹去95\%的内核（你的应用根本不需要那些）是一种什么体验？省出大量
的硬盘空间、应用运行得更加流畅——Unikernal正是这样！Unikernel 镜像都很小，由 MirageOS实现的一个 DNS server 才 184KB，一个 w
eb server 仅仅674 KB，小到令人恐怖的程度。因此开发在Unikernal上的项目通常没有传统操作系统的弊端，这无疑使它更加适应现代硬件系统。

快： 移除了传统的软件栈设计之后，Unikernel的风格是直入主题，将一切变得简单化，效率自然变得很高。对传统操作系统来说，也许那十几秒的
开机时间在你看来并不慢，但是在大型主机中，现有计算机的运行速度仍不能很好地满足要求，还有极大的改进空间。这一改进可以从计算机硬件入手
，比如制造更大规模的集成芯片、提高cpu主频等等，但如果从操作系统入手，可能会产生更好的效果。

Unikrenal可以说是从操作系统入手，提高电脑运行速度的一个很好的尝试。由于Unikernal的轻量，精简了冗余的结构，删减了多余的步骤，其启动
与停止都在毫秒级别，远远快于常规操作系统。运行在其上的应用程序也更加高效。

安全性： 这可能是Unikernel的最重大的优势，其实很多漏洞与应用程序没有关系，反而与应用程序并没有调用的系统服务有关系，移除了不需要的
内容，也就大大降低了系统被攻击的机会。举例来说：设计了一个与用户进行通信的网络服务器，如果用户要攻击骗取控制权，它会发现很难下手，因
为除了服务器需要的功能，其他的部件都被移除了，甚至连shell都没有。Unikernel的设计在保证了程序正常运行的同时，也大大限制了攻击者。在
计算机领域，有时候小而简单的东西相对而言更加安全，维护起来也更加容易，Unikernal就是这样。Unikernal中没有shell，没有密码文件，也
舍去了那些可能成为干扰源的视频和驱动。这极大地降低了Unikernal发生错误的可能，带来了更少的漏洞和更小的攻击面，大大地提高了安全性。

\section{劣势}

然而Unikernel并不是现代操作系统的救星，它也需要在一些优势和劣势之间作出权衡。其中最明显的几个劣势如下：

单进程：Unikernel的内部环境更像一个裸机，线性的，原始的内存状态，只有一个进程（不过多线程还是可以实现的），其实要做一个多进程的程
序也不是不可能，但是进程管理（启动，终止，监视进程等等）会造成很大的开销，Unikernel的优势会被削弱。

单用户：需要说明的是，单用户并不一定是缺陷，同样多用户的支持也需要很大的开销，如果要支持多用户，那就需要登录，验证，权限管理，用户之
间的隔离，还要有一些安全验证防止欺骗。但问题是：为什么一定需要多用户呢？Unikernel使用场景决定可以让一个用户占有一整个虚拟机。

糟糕的debug： 如果在开发过程，那样程序的debug比较简单：和正常的debug过程没有什么区别。但是在运行过程中如果出了问题，我们看不到栈，
没有tcpdump，没有传统的debug信息支持，我们很难知道到底出了什么问题。

\section{Unikernel的应用场景}

在了解了Unikernel的一些劣势之后，我们很容易得出什么时候该用Unikernel，从而最大程度发挥Unikernel的优势.

\begin{itemize}
    \item 不需要在一台机器上运行多个进程。
    \item 只需要单用户。
    \item 需要非常快的开启速度。
    \item 需要接入网络，对安全性有很高的要求。
    \item 可能需要大量部署的程序。
    \item 程序自带一套机制提供程序崩溃时的诊断。
    \item 不需要经常迭代版本或进行维护。
\end{itemize}