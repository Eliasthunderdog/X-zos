# Unikernel debug interface项目的可行性报告

## 明确目标：我们要做什么？

Unikernel作为近年来出现的一种制作功能专一化的极简虚拟机镜像的方法受到了大家的关注，目前来讲，它所面临的问题大致如下：

1. 对于一些错误处理，监视状态方面的局限性。
2. 在QEMU等监视器下的多余接口可以进一步进行优化。
3. 对于其中的应用程序进行版本滚动的时候，必须重新编译整个程序。
4. 对于较大规模的程序，现在还没有一种机制来确定它能否做成Unikernel而不影响其正确性。

而我们要做的 Unikernel debug interface，就是为了解决第一个问题，经过我们的讨论我们认为第二个问题也可以尝试解决。首要的内容则是我们希望能够改善现有的unikernel的构建部署风险大的问题。我们希望开发一个供开发者调用的接口，以及提供一种从宿主机获取unikernel的运行状态的方式（其实也是接口），类似各种编程语言中的异常抛出和处理一样，能够给开发者提供更加便利的调试，并且在部署阶段出现问题时反馈足够的信息。

## 为什么可以这样做？

### 先从虚拟化技术谈起

虚拟化技术其实就是一种仿真模拟技术，让程序“以为”自己占有整个硬件，每一个运行的进程都以为它是系统唯一的进程，占有了所有
的CPU时间，换句话说，虚拟化技术使得程序在实际设备上的运行 P 和在一台“理想”的设备上运行 P' 从运行结果上来讲是等价的，而
且程序并不需要为虚拟化做出任何的改变。

也就是说，虚拟化技术其实并没有改变程序本身的任何性质，任何程序本身就可以做到的事，只要提供了相应的虚拟化手段，就可以在虚
拟机中做到，这种虚拟化之后的程序运行的性质不变，于是我们在宿主机中可以做的事，在虚拟机中一样可以做到。

这种技术为我们带来了很多实用的功能：从硬件上来讲，有各种链路的多路复用，从操作系统层面上，有文件系统的隔离。而且虚拟化所
带来的各种管理层面上的优势，比如我可以已非常低的开销进行整机克隆，有巨大的可移植性，总之虚拟机提供的更深层次的隔离使得基
于虚拟机创建网络服务变得非常方便，并且相对安全。

### Unikernel对虚拟机的的改变意味着什么？

Unikernel改变了操作系统的层次结构，或者说，几乎没有了层次结构。（使它变得不可控，写到调研报告里）
但是它仍然有一个可以用的文件系统，精简到它可以用的程度，这样可以获得最大的性能。

那么我们的错误信息以及unikernel的状态输出到哪里？最显然的方法是写在虚拟机挂载的虚拟磁盘上。这样做的目的就在于可以在不对虚拟技术作出改变的前提下获取信息。也就是说，我们可以非常方便地获取程序运行的状态。然后我们再将它从虚拟磁盘上读出来即可，注意这里在宿主机里读出来，是因为我们假设最坏的情况：unikernel已经完全宕机，我们只能通过宿主机查看它的运行日至和当前状态。

Unikernel这样重新思考操作系统的组织形式，尤其是对于云计算平台提供服务的模式来说，它重新定义了我们认识一个“服务”（包括应
用程序，虚拟机等）的提供形式，在传统的思维中，我们通常认为所有的服务都是准备好处理用户请求的，这也就意味着我们需要应对各
种各样可能的请求，为每一种请求提供对应的服务，即便事实上它并不需要。那么，我们应该考虑如下问题：我们可不可以根据用户的需
求提供服务呢？Unikernel的设计和实践告诉我们这是可以的，而且对我们来说有极大的好处。

首先，如果能在短时间内（毫秒级）建立用户所需要的服务，那么我们完全可以不让所有可能的服务处于“空转”状态，而是一种近似于“
按需分配”的方式提供给用户，这将大大节省计算资源。

其次，我们这样做减少了可能的攻击面（attack surface）因为冗余的服务都被剔除了，精简就意味着可能用来发动攻击的资源少。

### 需要改变什么

目前的问题是：我们如何提供一个调用来让unikernel能够将自己的状态和错误信息写入虚拟磁盘，再将其在宿主机上读出来呢？

#### 改变1：具体的接口

通常情况下我们在对一个程序进行调试的时候需要的就是程序的状态，比如寄存器，栈，变量信息等等，因此我们需要一个接口能够在运行的时候获取这些信息，并将它们写入到磁盘上。同时作为对错误的处理，我们需要让unikernel停止到某一个状态防止它进一步造成损害。

比如说我们开发的接口名字叫：

```c
void error_handle(char * msg, FILE *p);
```

这个函数需要提供一个msg作为错误信息写入到磁盘中，并且将unikernel转到某个停止运行的状态。

```c
void print_log(FILE *p);
```

这个函数可以完成将寄存器状态，内存状态等等可能的错误信息写入到文件中，并将unikernel转到某个暂停的状态。

对于传统的程序调试来说，我们有强大的调试工具可以使用，但是在unikernel中，情况不允许我们运行多个进程，而且将unikernel暂停到某个状态也并不方便，于是我们需要开发这样的一个接口，unikernel的特性也允许这样一个函数具有足够的“权限”获取这些信息。

#### 可行性分析

第一，我们可以获得这些信息吗？程序本身能不能做到这样的事？

这个问题的回答无疑是：能。在组织形式相当“原始”（为了提高性能）的unikernel里，其实并没有传统操作系统中意义上的“权限”，因为进程只有一个，在这种情况下并没有任何的机制可以禁止程序做任何事，连内核空间和用户空间都不分了，什么都是可见的。

第二，这样的设计是否会降低unikernel的性能？

就像之前提到的，unikernel并不是虚拟化了一个完整的文件系统，它只做了“最低要求”，使得它可以完成文件的I/O，这样的I/O并不会降低unikernel的性能。举个例子：

涉及到I/O，尤其是文件I/O的unikernel，比如数据库Mysql的unikernel,可以顺利地保存数据，并在之后成功读取，所以在I/O方面虽然没有完整的文件系统，但是一样实现了自身的需要。

第三，进行错误处理后怎样保证unikernel不会造成更大的损失？

我们希望unikernel能够在发生错误，处理错误，提供错误信息之后进入到一种“停止”状态，我们可以用一个无限循环，也可以让它停机，然而最理想的情况是，进入到一种“等待检查”的状态。这样我们可以在宿主机上通过GDB查看它的状态，进一步的，我们可以修改它的状态，对于错误的复现和排查也非常有好处。

#### 改变2：gdb 远程调试的过程

在这学期第一个实验中，我们对内核进行了调试，就是用的gdb进行远程调试。

#### 一个设想（已经毙掉）

能不能完全像管理一个应用程序一样管理unikernel呢？我们希望monitor提供的接口能够提供像一个正常的应用程序一样的抽象，那样会不会让unikernel的管理难度降低呢？

这个问题在和其他小组成员进行讨论后我们认为不行，原因很简单，我们平时能够非常方便地管理进程，就是因为在背后有很多层的抽象机制，也正是这些造成的开销。我们不希望这种问题存在，目前看来，unikernel为了得到卓越的性能牺牲了很多原本非常人性化的设计理念，但是其性能带来的巨大回报值得我们作出改变，也有很多可以在保证效率的前提下改善其开发和维护效率的方法。